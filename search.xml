<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于Hadoop</title>
    <url>/2020/03/28/%E5%85%B3%E4%BA%8EHadoop/</url>
    <content><![CDATA[<p>Hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。它的设计是从单个服务器扩展到数千个机器，每个都提供本地计算和存储。</p>
<h2>Hadoop - 简介</h2>
Hadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点

<p>特别适合写一次，读多次的场景</p>
<p>适合<br>-大规模数据<br>-流式数据（写一次，读多次）<br>-商用硬件（一般硬件）<br>不适合<br>*低延时的数据访问<br>*大量的小文件<br>*频繁修改文件（基本就是写1次）</p>
<p>Hadoop架构<br><img src="/images/innerimage/branch/h2.png" alt="hadoop"></p>
<p>HDFS: 分布式文件存储<br>YARN: 分布式资源管理<br>MapReduce: 分布式计算<br>Others: 利用YARN的资源管理功能实现其他的数据处理方式<br>内部各个节点基本都是采用Master-Woker架构</p>
<a id="more"></a>
<p><img src="/images/innerimage/branch/hadoop.png" alt="hadoop"></p>
]]></content>
  </entry>
  <entry>
    <title>Spring：AOP--面向切面编程</title>
    <url>/2020/03/20/Spring%EF%BC%9AAOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="a">什么是AOP</h3>
AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

<a id="more"></a>

<p><img src="/images/innerimage/SpringImage/320013.png" alt="cg"></p>
<h3 id="b">Aop在Spring中的作用</h3>
<b>提供声明式事务；允许用户自定义切面</b>

<p>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….<br>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。<br>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。<br>目标（Target）：被通知对象。<br>代理（Proxy）：向目标对象应用通知之后创建的对象。<br>切入点（PointCut）：切面通知 执行的 “地点”的定义。<br>连接点（JointPoint）：与切入点匹配的执行点。</p>
<p><img src="/images/innerimage/SpringImage/320014.png" alt="cg"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="/images/innerimage/SpringImage/320015.png" alt="cg"></p>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h3 id="c">使用Spring实现Aop</h3>
【重点】使用AOP织入，需要导入一个依赖包！

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><b>第一种方式</b><br><b>通过 Spring API 实现</b></p>
<p>首先编写我们的业务接口和实现类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line"></span><br><span class="line">    public void delete();</span><br><span class="line"></span><br><span class="line">    public void update();</span><br><span class="line"></span><br><span class="line">    public void search();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">add</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"增加用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">delete</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"更新用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">search</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"查询用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Log implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //method : 要执行的目标对象的方法</span><br><span class="line">    //objects : 被调用的方法的参数</span><br><span class="line">    //Object : 目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println( o.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"方法被执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class AfterLog implements AfterReturningAdvice &#123;</span><br><span class="line">    //returnValue 返回值</span><br><span class="line">    //method被调用的方法</span><br><span class="line">    //args 被调用的方法的对象的参数</span><br><span class="line">    //target 被调用的目标对象</span><br><span class="line">    @Override</span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了"</span> + target.getClass().getName()</span><br><span class="line">        +<span class="string">"的"</span>+method.getName()+<span class="string">"方法,"</span></span><br><span class="line">        +<span class="string">"返回值："</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"userService"</span> class=<span class="string">"com.kuang.service.UserServiceImpl"</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"log"</span> class=<span class="string">"com.kuang.log.Log"</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"afterLog"</span> class=<span class="string">"com.kuang.log.AfterLog"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--aop的配置--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点  expression:表达式匹配要执行的方法--&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>/&gt;</span><br><span class="line">        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"log"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"afterLog"</span> pointcut-ref=<span class="string">"pointcut"</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</p>
<p><b>第二种方式</b><br><b>自定义类来实现Aop</b></p>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class DiyPointcut &#123;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">before</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行前---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">after</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行后---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去spring中配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="line">&lt;!--注册bean--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"diy"</span> class=<span class="string">"com.kuang.config.DiyPointcut"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--aop的配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br><span class="line">    &lt;aop:aspect ref=<span class="string">"diy"</span>&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"diyPonitcut"</span> expression=<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>/&gt;</span><br><span class="line">        &lt;aop:before pointcut-ref=<span class="string">"diyPonitcut"</span> method=<span class="string">"before"</span>/&gt;</span><br><span class="line">        &lt;aop:after pointcut-ref=<span class="string">"diyPonitcut"</span> method=<span class="string">"after"</span>/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>第三种方式</b><br><b>使用注解实现</b></p>
<p>第一步：编写一个注解实现的增强类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotationPointcut &#123;</span><br><span class="line">    @Before(<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    public void <span class="function"><span class="title">before</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行前---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    public void <span class="function"><span class="title">after</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行后---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕前"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签名:"</span>+jp.getSignature());</span><br><span class="line">        //执行目标方法proceed</span><br><span class="line">        Object proceed = jp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"环绕后"</span>);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"annotationPointcut"</span> class=<span class="string">"com.kuang.config.AnnotationPointcut"</span>/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<p>aop:aspectj-autoproxy：说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 </span><br><span class="line"></span><br><span class="line">&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为<span class="literal">false</span>，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=<span class="string">"true"</span>/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为<span class="literal">false</span>，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>










]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring：使用注解开发</title>
    <url>/2020/03/20/Spring%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="a">说明</h3>
在spring4之后，想要使用注解形式，必须得要引入aop的包

<p><img src="/images/innerimage/SpringImage/320012.png" alt="cg"></p>
<p>在配置文件当中，还得要引入一个context约束</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="b">Bean的实现</h3>
我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！

<p>1.配置扫描哪些包下的注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--指定注解扫描包--&gt;</span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.kuang.pojo"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>2.在指定包下编写类，增加注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component(<span class="string">"user"</span>)</span><br><span class="line">// 相当于配置文件中 &lt;bean id=<span class="string">"user"</span> class=<span class="string">"当前注解的类"</span>/&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">    public String name = <span class="string">"秦疆"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    ApplicationContext applicationContext =</span><br><span class="line">        new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c">属性注入</h3>
使用注解注入属性
1.可以不用提供set方法，直接在直接名上添加@value("值")

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component(<span class="string">"user"</span>)</span><br><span class="line">// 相当于配置文件中 &lt;bean id=<span class="string">"user"</span> class=<span class="string">"当前注解的类"</span>/&gt;</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(<span class="string">"秦疆"</span>)</span><br><span class="line">    // 相当于配置文件中 &lt;property name=<span class="string">"name"</span> value=<span class="string">"秦疆"</span>/&gt;</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.如果提供了set方法，在set方法上添加@value(“值”);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component(<span class="string">"user"</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"秦疆"</span>)</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d">衍生注解</h3>
我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！

<p>@Component三个衍生注解</p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<p>@Controller：web层<br>@Service：service层<br>@Repository：dao层<br>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<h3 id="e">自动装配注解</h3>
在Bean的自动装配已经讲过了，可以回顾！

<h3 id="f">作用域</h3>
@scope

<p>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。<br>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Controller(<span class="string">"user"</span>)</span><br><span class="line">@Scope(<span class="string">"prototype"</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(<span class="string">"秦疆"</span>)</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="g">小结</h3>
<b>XML与注解比较</b>

<p>XML可以适用任何场景 ，结构清晰，维护方便<br>注解不是自己提供的类使用不了，开发简单方便<br><b>xml与注解整合开发 ：推荐最佳实践</b></p>
<p>xml管理Bean<br>注解完成属性注入<br>使用过程中， 可以不用扫描，扫描是为了类上的注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>进行注解驱动注册，从而使注解生效<br>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册<br>如果不扫描包，就需要手动配置bean<br>如果不加注解驱动，则注入的值为null！</p>
<h3 id="h">基于Java类进行配置</h3>

<p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1.编写一个实体类，Dog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component  //将这个类标注为Spring的一个组件，放到容器中！</span><br><span class="line">public class Dog &#123;</span><br><span class="line">    public String name = <span class="string">"dog"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.新建一个config配置包，编写一个MyConfig配置类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration  //代表这是一个配置类</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span><br><span class="line">    public Dog <span class="function"><span class="title">dog</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new Dog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test2</span></span>()&#123;</span><br><span class="line">    ApplicationContext applicationContext =</span><br><span class="line">            new AnnotationConfigApplicationContext(MyConfig.class);</span><br><span class="line">    Dog dog = (Dog) applicationContext.getBean(<span class="string">"dog"</span>);</span><br><span class="line">    System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.成功输出结果！<br>导入其他配置如何做呢？</p>
<p>1.我们再编写一个配置类！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration  //代表这是一个配置类</span><br><span class="line">public class MyConfig2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在之前的配置类中我们来选择导入这个配置类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Dog <span class="function"><span class="title">dog</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> new Dog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring：自动装配</title>
    <url>/2020/03/20/Spring%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h2 id="z">Bean的自动装配</h2>
自动装配是使用spring满足bean依赖的一种方法
spring会在应用上下文中为某个bean寻找其依赖的bean。
Spring中bean有三种装配机制，分别是：

<p>1.在xml中显式配置；<br>2.在java中显式配置；<br>3.隐式的bean发现机制和自动装配。</p>
<a id="more"></a>

<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<p>1.组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；<br>2.自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；<br>组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。</p>
<p><b>推荐不使用自动装配xml配置 , 而使用注解 .</b></p>
<h3 id="a">测试环境搭建</h3>
1.新建一个项目
2.新建两个实体类，Cat Dog 都有一个叫的方法

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    public void <span class="function"><span class="title">shout</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"miao~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">    public void <span class="function"><span class="title">shout</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"wang~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.新建一个用户类 User</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Cat cat;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    private String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写Spring配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"cat"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"cat"</span> ref=<span class="string">"cat"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dog"</span> ref=<span class="string">"dog"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"str"</span> value=<span class="string">"qinjiang"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testMethodAutowire</span></span>() &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">        user.getCat().shout();</span><br><span class="line">        user.getDog().shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果正常输出，环境OK</p>
<h3 id="b">byName</h3>
<b>autowire byName (按名称自动装配)</b>

<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1.修改bean配置，增加一个属性 autowire=”byName”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span> autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"str"</span> value=<span class="string">"qinjiang"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>2.再次测试，结果依旧成功输出！<br>3.我们将 cat 的bean id修改为 catXXX<br>4.再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。<br><b>小结：</b></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<p>1.将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。<br>2.去spring容器中寻找是否有此字符串名称id的对象。<br>3.如果有，就取出注入；如果没有，就报空指针异常。</p>
<h3 id="c">byType</h3>
<b>autowire byType (按类型自动装配)</b>

<p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>1.将user的bean配置修改一下 ： autowire=”byType”<br>2.测试，正常输出<br>3.在注册一个cat 的bean对象！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat2"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span> autowire=<span class="string">"byType"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"str"</span> value=<span class="string">"qinjiang"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>4.测试，报错：NoUniqueBeanDefinitionException<br>5.删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h3 id="d">使用注解</h3>
jdk1.5开始支持注解，spring2.5开始全面支持注解。

<p>准备工作： 利用注解的方式注入属性。</p>
<p>1.在spring配置文件中引入context文件头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure>

<p>2.开启属性注解支持！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="e">@Autowired</h3>
@Autowired是按类型自动转配的，不支持id匹配。
需要导入 spring-aop的包！
测试：

<p>1.将User类中的set方法去掉，使用@Autowired注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Cat cat;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Dog dog;</span><br><span class="line">    private String str;</span><br><span class="line"></span><br><span class="line">    public Cat <span class="function"><span class="title">getCat</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    public Dog <span class="function"><span class="title">getDog</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">    public String <span class="function"><span class="title">getStr</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.此时配置文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>3.测试，成功输出结果！<br>【秦疆科普时间】</p>
<p>@Autowired(required=false) 说明： false，对象可以为null；true，对象必须存对象，不能为null。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//如果允许对象为null，设置required = <span class="literal">false</span>,默认为<span class="literal">true</span></span><br><span class="line">@Autowired(required = <span class="literal">false</span>)</span><br><span class="line">private Cat cat;</span><br></pre></td></tr></table></figure>

<h3 id="f">@Qualifier</h3>
@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配
@Qualifier不能单独使用。
测试实验步骤：

<p>1.配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog1"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dog2"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat1"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat2"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>2.没有加Qualifier测试，直接报错<br>3.在属性上添加Qualifier注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = <span class="string">"cat2"</span>)</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = <span class="string">"dog2"</span>)</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>

<p>4.测试，成功输出！</p>
<h3 id="g">@Resource</h3>
@Resource如有指定的name属性，先按该属性进行byName方式查找装配；
其次再进行默认的byName方式进行装配；
如果以上都不成功，则按byType的方式自动装配。
都不成功，则报异常。

<p>实体类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    //如果允许对象为null，设置required = <span class="literal">false</span>,默认为<span class="literal">true</span></span><br><span class="line">    @Resource(name = <span class="string">"cat2"</span>)</span><br><span class="line">    private Cat cat;</span><br><span class="line">    @Resource</span><br><span class="line">    private Dog dog;</span><br><span class="line">    private String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beans.xml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat1"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat2"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"cat1"</span> class=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>实体类上只保留注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private Cat cat;</span><br><span class="line">@Resource</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure>

<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h2 id="x">小结</h2>

<p>@Autowired与@Resource异同：</p>
<p>1.@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。<br>2.@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用<br>3.@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。<br>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring：依赖注入（DI）</title>
    <url>/2020/03/20/Spring%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/</url>
    <content><![CDATA[<h2 id="z">依赖注入（DI）</h2>
依赖注入（Dependency Injection,DI）。
依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .
注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .

<a id="more"></a>

<h3 id="a">构造器注入</h3>
我们在之前的案例4已经详细讲过了

<h3 id="b">settet注入 (重点)</h3>
要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .

<p>测试pojo类 :</p>
<p><b>Address.java</b></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getAddress</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>Student.java</b></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbys;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbys(List&lt;String&gt; hobbys) &#123;</span><br><span class="line">        this.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+ name</span><br><span class="line">                + <span class="string">",address="</span>+ address.getAddress()</span><br><span class="line">                + <span class="string">",books="</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String book:books)&#123;</span><br><span class="line">            System.out.print(<span class="string">"&lt;&lt;"</span>+book+<span class="string">"&gt;&gt;\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n爱好:"</span>+hobbys);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"card:"</span>+card);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"games:"</span>+games);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"wife:"</span>+wife);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"info:"</span>+info);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、常量注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"student"</span> class=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"小明"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test01</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">    Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Bean注入</p>
<p>注意点：这里的值是一个引用，ref</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"addr"</span> class=<span class="string">"com.kuang.pojo.Address"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"address"</span> value=<span class="string">"重庆"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"student"</span> class=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"小明"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"address"</span> ref=<span class="string">"addr"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、数组注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"student"</span> class=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"小明"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"address"</span> ref=<span class="string">"addr"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"books"</span>&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;西游记&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;红楼梦&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;水浒传&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>4、List注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"hobbys"</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;听歌&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;看电影&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;爬山&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>5、Map注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"card"</span>&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=<span class="string">"中国邮政"</span> value=<span class="string">"456456456465456"</span>/&gt;</span><br><span class="line">        &lt;entry key=<span class="string">"建设"</span> value=<span class="string">"1456682255511"</span>/&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>6、set注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"games"</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">set</span>&gt;</span><br><span class="line">        &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;BOB&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;COC&lt;/value&gt;</span><br><span class="line">    &lt;/<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>7、Null注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"wife"</span>&gt;&lt;null/&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>8、Properties注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">"info"</span>&gt;</span><br><span class="line">    &lt;props&gt;</span><br><span class="line">        &lt;prop key=<span class="string">"学号"</span>&gt;20190604&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=<span class="string">"性别"</span>&gt;男&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=<span class="string">"姓名"</span>&gt;小明&lt;/prop&gt;</span><br><span class="line">    &lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/images/innerimage/SpringImage/320010.png" alt="cg"></p>
<h3 id="c">拓展注入实现</h3>
User.java ： 【注意：这里没有有参构造器！】

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                ", age=" + age +</span></span><br><span class="line"><span class="string">                '</span>&#125;<span class="string">';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>1、P命名空间注入** : 需要在头文件中假如约束文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line"></span><br><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置<span class="built_in">set</span>方法--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span> p:name=<span class="string">"狂神"</span> p:age=<span class="string">"18"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>2、c 命名空间注入 : 需要在头文件中假如约束文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">导入约束 : xmlns:c=<span class="string">"http://www.springframework.org/schema/c"</span></span><br><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置<span class="built_in">set</span>方法--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span> c:name=<span class="string">"狂神"</span> c:age=<span class="string">"18"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>发现问题：爆红了，刚才我们没有写有参构造！<br>解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！<br>测试代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test02</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="d">Bean的作用域</h3>
在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .

<p><img src="/images/innerimage/SpringImage/320011.png" alt="cg"></p>
<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h3 id="e">Singleton</h3>
当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"ServiceImpl"</span> class=<span class="string">"cn.csdn.service.ServiceImpl"</span> scope=<span class="string">"singleton"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test03</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    User user2 = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f">Prototype</h3>
当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"account"</span> class=<span class="string">"com.foo.DefaultAccount"</span> scope=<span class="string">"prototype"</span>/&gt;  </span><br><span class="line"> 或者</span><br><span class="line">&lt;bean id=<span class="string">"account"</span> class=<span class="string">"com.foo.DefaultAccount"</span> singleton=<span class="string">"false"</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="g">Request</h3>
当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"loginAction"</span> class=cn.csdn.LoginAction<span class="string">" scope="</span>request<span class="string">"/&gt;</span></span><br></pre></td></tr></table></figure>

<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h3 id="h">Session</h3>
当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"userPreferences"</span> class=<span class="string">"com.foo.UserPreferences"</span> scope=<span class="string">"session"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring：第一个程序</title>
    <url>/2020/03/20/Spring%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="a">导入Jar包</h3>
注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="b">编写代码</h3>
1.编写一个Hello实体类

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.编写我们的spring文件 , 这里我们命名为beans.xml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"hello"</span> class=<span class="string">"com.kuang.pojo.Hello"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"name"</span> value=<span class="string">"Spring"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>3.我们可以去进行测试了 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    //解析beans.xml文件 , 生成管理相应的Bean对象</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    //getBean : 参数即为spring配置文件中bean的id .</span><br><span class="line">    Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">    hello.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="c">思考</h3>
1.Hello 对象是谁创建的 ? 【 hello 对象是由Spring创建的 】
2.Hello 对象的属性是怎么设置的 ? 【hello 对象的属性是由Spring容器设置的 】
这个过程就叫控制反转 :

<p>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的<br>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .<br>依赖注入 : 就是利用set方法来进行注入的.</p>
<p><b>IOC是一种编程思想，由主动的编程变成被动的接收</b></p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
<h3 id="d">修改案例一</h3>
我们在案例一中， 新增一个Spring配置文件beans.xml

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"MysqlImpl"</span> class=<span class="string">"com.kuang.dao.impl.UserDaoMySqlImpl"</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"OracleImpl"</span> class=<span class="string">"com.kuang.dao.impl.UserDaoOracleImpl"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"ServiceImpl"</span> class=<span class="string">"com.kuang.service.impl.UserServiceImpl"</span>&gt;</span><br><span class="line">        &lt;!--注意: 这里的name并不是属性 , 而是<span class="built_in">set</span>方法后面的那部分 , 首字母小写--&gt;</span><br><span class="line">        &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"userDao"</span> ref=<span class="string">"OracleImpl"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test2</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(<span class="string">"ServiceImpl"</span>);</span><br><span class="line">    serviceImpl.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p>
<h2 id="z">IOC创建对象方式</h2>

<h3 id="e">通过无参构造方法来创建</h3>
1、User.java

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">User</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"user无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、beans.xml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"user"</span> class=<span class="string">"com.kuang.pojo.User"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"name"</span> value=<span class="string">"kuangshen"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    //在执行getBean的时候, user已经创建好了 , 通过无参构造</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    //调用对象的方法 .</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h3 id="f">通过有参构造方法来创建</h3>

<p>1、UserT.java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class UserT &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public UserT(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、beans.xml 有三种方式编写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userT"</span> class=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span><br><span class="line">    &lt;!-- index指构造方法 , 下标从0开始 --&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">"0"</span> value=<span class="string">"kuangshen2"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userT"</span> class=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span><br><span class="line">    &lt;!-- name指参数名 --&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">"name"</span> value=<span class="string">"kuangshen2"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第三种根据参数类型设置 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userT"</span> class=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">type</span>=<span class="string">"java.lang.String"</span> value=<span class="string">"kuangshen2"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testT</span></span>()&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    UserT user = (UserT) context.getBean(<span class="string">"userT"</span>);</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="y">Spring配置</h2>
<h3 id="g">别名</h3>
alias 设置别名 , 为bean设置别名 , 可以设置多个别名


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span><br><span class="line">&lt;<span class="built_in">alias</span> name=<span class="string">"userT"</span> <span class="built_in">alias</span>=<span class="string">"userNew"</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="h">Bean的配置</h3>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">    id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span><br><span class="line">    如果配置id,又配置了name,那么name是别名</span><br><span class="line">    name可以设置多个别名,可以用逗号,分号,空格隔开</span><br><span class="line">    如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span><br><span class="line"></span><br><span class="line">    class是bean的全限定名=包名+类名</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"hello"</span> name=<span class="string">"hello2 h2,h3;h4"</span> class=<span class="string">"com.kuang.pojo.Hello"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"Spring"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<h3 id="i">import</h3>
团队的合作通过import来实现 .


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;import resource=<span class="string">"&#123;path&#125;/beans.xml"</span>/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis：缓存</title>
    <url>/2020/03/19/MyBatis%EF%BC%9A%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="a">缓存简介</h3>
1.什么是缓存 [ Cache ]？

<p>存在内存中的临时数据。<br>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</p>
<a id="more"></a>
<p>2.为什么使用缓存？</p>
<p>减少和数据库的交互次数，减少系统开销，提高系统效率。<br>3.什么样的数据能使用缓存？</p>
<p>经常查询并且不经常改变的数据。</p>
<h3 id="b">Mybatis缓存</h3>
MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存

<p>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）<br>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。<br>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p>
<h3 id="c">一级缓存</h3>
一级缓存也叫本地缓存：

<p>与数据库同一次会话期间查询到的数据会放在本地缓存中。<br>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</p>
<h3 id="d">初体验测试</h3>
1.在mybatis中加入日志，方便测试结果
2.编写接口方法

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//根据id查询用户</span><br><span class="line">User queryUserById(@Param(<span class="string">"id"</span>) int id);</span><br></pre></td></tr></table></figure>

<p>3.接口对应的Mapper文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"queryUserById"</span> resultType=<span class="string">"user"</span>&gt;</span><br><span class="line">    select * from user <span class="built_in">where</span> id = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    User user2 = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.结果分析</p>
<p><img src="/images/innerimage/MybatisImage/20200319002.png" alt="cg"></p>
<h3 id="e">一级缓存失效的四种情况</h3>
一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；
一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！

<p>sqlSession不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    SqlSession session2 = MybatisUtils.getSession();</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    User user2 = mapper2.queryUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">    session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：发现发送了两条SQL语句！结论：每个sqlSession中的缓存相互独立</p>
<p>sqlSession相同，查询条件不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    User user2 = mapper2.queryUserById(2);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：发现发送了两条SQL语句！很正常的理解，结论：当前缓存中，不存在这个数据</p>
<p>sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//修改用户</span><br><span class="line">int updateUser(Map map);</span><br></pre></td></tr></table></figure>

<p>编写SQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"map"</span>&gt;</span><br><span class="line">    update user <span class="built_in">set</span> name = <span class="comment">#&#123;name&#125; where id = #&#123;id&#125;</span></span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    HashMap map = new HashMap();</span><br><span class="line">    map.put(<span class="string">"name"</span>,<span class="string">"kuangshen"</span>);</span><br><span class="line">    map.put(<span class="string">"id"</span>,4);</span><br><span class="line">    mapper.updateUser(map);</span><br><span class="line"></span><br><span class="line">    User user2 = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line"></span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：查询在中间执行了增删改操作后，重新执行了，结论：因为增删改操作可能会对当前数据产生影响</p>
<p>sqlSession相同，手动清除一级缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    session.clearCache();//手动清除缓存</span><br><span class="line"></span><br><span class="line">    User user2 = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line"></span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>所以说，一级缓存就是一个map</b></p>
<h2 id="f">二级缓存</h2>
二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存
基于namespace级别的缓存，一个名称空间，对应一个二级缓存；
工作机制

<p>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；<br>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；<br>新的会话查询信息，就可以从二级缓存中获取内容；<br>不同的mapper查出的数据会放在自己对应的缓存（map）中；</p>
<h3 id="g">使用步骤</h3>
官方文档

<p>1.开启全局缓存 【mybatis-config.xml】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;setting name=<span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>2.去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br><span class="line"></span><br><span class="line">官方示例=====&gt;查看官方文档</span><br><span class="line">&lt;cache</span><br><span class="line">  eviction=<span class="string">"FIFO"</span></span><br><span class="line">  flushInterval=<span class="string">"60000"</span></span><br><span class="line">  size=<span class="string">"512"</span></span><br><span class="line">  readOnly=<span class="string">"true"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。--&gt;</span><br></pre></td></tr></table></figure>

<p>3.代码测试</p>
<p>所有的实体类先实现序列化接口<br>测试代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testQueryUserById</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    SqlSession session2 = MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.queryUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    session.close();</span><br><span class="line"></span><br><span class="line">    User user2 = mapper2.queryUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="h">结论</h3>
只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据
查出的数据都会被默认先放在一级缓存中
只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中

<h3 id="i">缓存原理</h3>

<p><img src="/images/innerimage/MybatisImage/319004.png" alt="cg"></p>
<h3 id="j">EhCache</h3>
第三方缓存实现--EhCache: 查看百度百科

<p>官方文档<br>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；<br>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在mapper.xml中使用对应的缓存即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace = “org.acme.FooMapper” &gt; </span><br><span class="line">    &lt;cache <span class="built_in">type</span> = “org.mybatis.caches.ehcache.EhcacheCache” /&gt; </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:noNamespaceSchemaLocation=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span><br><span class="line">         updateCheck=<span class="string">"false"</span>&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span><br><span class="line">       user.home – 用户主目录</span><br><span class="line">       user.dir  – 用户当前工作目录</span><br><span class="line">       java.io.tmpdir – 默认临时文件路径</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;diskStore path=<span class="string">"./tmpdir/Tmp_EhCache"</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            eternal=<span class="string">"false"</span></span><br><span class="line">            maxElementsInMemory=<span class="string">"10000"</span></span><br><span class="line">            overflowToDisk=<span class="string">"false"</span></span><br><span class="line">            diskPersistent=<span class="string">"false"</span></span><br><span class="line">            timeToIdleSeconds=<span class="string">"1800"</span></span><br><span class="line">            timeToLiveSeconds=<span class="string">"259200"</span></span><br><span class="line">            memoryStoreEvictionPolicy=<span class="string">"LRU"</span>/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;cache</span><br><span class="line">            name=<span class="string">"cloud_user"</span></span><br><span class="line">            eternal=<span class="string">"false"</span></span><br><span class="line">            maxElementsInMemory=<span class="string">"5000"</span></span><br><span class="line">            overflowToDisk=<span class="string">"false"</span></span><br><span class="line">            diskPersistent=<span class="string">"false"</span></span><br><span class="line">            timeToIdleSeconds=<span class="string">"1800"</span></span><br><span class="line">            timeToLiveSeconds=<span class="string">"1800"</span></span><br><span class="line">            memoryStoreEvictionPolicy=<span class="string">"LRU"</span>/&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      name:缓存名称。</span><br><span class="line">      maxElementsInMemory:缓存最大数目</span><br><span class="line">      maxElementsOnDisk：硬盘最大缓存个数。</span><br><span class="line">      eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span><br><span class="line">      overflowToDisk:是否保存到磁盘，当系统当机时</span><br><span class="line">      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=<span class="literal">false</span>对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span><br><span class="line">      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=<span class="literal">false</span>对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span><br><span class="line">      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is <span class="literal">false</span>.</span><br><span class="line">      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span><br><span class="line">      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span><br><span class="line">      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span><br><span class="line">      clearOnFlush：内存数量最大时是否清除。</span><br><span class="line">      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span><br><span class="line">      FIFO，first <span class="keyword">in</span> first out，这个是大家最熟的，先进先出。</span><br><span class="line">      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span><br><span class="line">      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span><br><span class="line">   --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis：一对多、多对一处理</title>
    <url>/2020/03/19/MyBatis%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A%E3%80%81%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2>多对一的处理</h2>
多对一的理解：

<p>多个学生对应一个老师<br>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！</p>
<h3 id="shujuku">数据库设计</h3>

<p><img src="/images/innerimage/MybatisImage/319001.png" alt="cg"></p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">  `id` INT(10) NOT NULL,</span><br><span class="line">  `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO teacher(`id`, `name`) VALUES (1, <span class="string">'秦老师'</span>); </span><br><span class="line"></span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` INT(10) NOT NULL,</span><br><span class="line">  `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">  `tid` INT(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `fktid` (`tid`),</span><br><span class="line">  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (<span class="string">'1'</span>, <span class="string">'小明'</span>, <span class="string">'1'</span>); </span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (<span class="string">'2'</span>, <span class="string">'小红'</span>, <span class="string">'1'</span>); </span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (<span class="string">'3'</span>, <span class="string">'小张'</span>, <span class="string">'1'</span>); </span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (<span class="string">'4'</span>, <span class="string">'小李'</span>, <span class="string">'1'</span>); </span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (<span class="string">'5'</span>, <span class="string">'小王'</span>, <span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>

<h3  id="dajiance">搭建测试环境</h3>
【Lombok的使用】

<p>1.IDEA安装Lombok插件<br>2.引入Maven依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.在代码中增加注解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Data //GET,SET,ToString，有参，无参构造</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    //多个学生可以是同一个老师，即多对一</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写实体类对应的Mapper接口 【两个】</p>
<p>无论有没有需求，都应该写上，以备后来之需！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface StudentMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface TeacherMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写Mapper接口对应的 mapper.xml配置文件 【两个】</p>
<p>无论有没有需求，都应该写上，以备后来之需！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.kuang.mapper.StudentMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.kuang.mapper.TeacherMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h3 id="anchaxun">按查询嵌套处理</h3>

<p>1.给StudentMapper接口增加方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取所有学生及对应老师的信息</span><br><span class="line">public List&lt;Student&gt; getStudents();</span><br></pre></td></tr></table></figure>

<p>2.编写对应的Mapper文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.kuang.mapper.StudentMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    需求：获取所有学生及对应老师的信息</span><br><span class="line">    思路：</span><br><span class="line">        1. 获取所有学生的信息</span><br><span class="line">        2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span><br><span class="line">        3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span><br><span class="line">            1. 做一个结果集映射：StudentTeacher</span><br><span class="line">            2. StudentTeacher结果集的类型为 Student</span><br><span class="line">            3. 学生中老师的属性为teacher，对应数据库中为tid。</span><br><span class="line">               多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span><br><span class="line">            4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"getStudents"</span> resultMap=<span class="string">"StudentTeacher"</span>&gt;</span><br><span class="line">      select * from student</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"StudentTeacher"</span> <span class="built_in">type</span>=<span class="string">"Student"</span>&gt;</span><br><span class="line">        &lt;!--association关联属性  property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="line">        &lt;association property=<span class="string">"teacher"</span>  column=<span class="string">"tid"</span> javaType=<span class="string">"Teacher"</span> select=<span class="string">"getTeacher"</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="line">    association中column多参数配置：</span><br><span class="line">        column=<span class="string">"&#123;key=value,key=value&#125;"</span></span><br><span class="line">        其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"getTeacher"</span> resultType=<span class="string">"teacher"</span>&gt;</span><br><span class="line">        select * from teacher <span class="built_in">where</span> id = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>3.编写完毕去Mybatis配置文件中，注册Mapper！<br>4.注意点说明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">"StudentTeacher"</span> <span class="built_in">type</span>=<span class="string">"Student"</span>&gt;</span><br><span class="line">    &lt;!--association关联属性  property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="line">    &lt;association property=<span class="string">"teacher"</span>  column=<span class="string">"&#123;id=tid,name=tid&#125;"</span> javaType=<span class="string">"Teacher"</span> select=<span class="string">"getTeacher"</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="line">association中column多参数配置：</span><br><span class="line">    column=<span class="string">"&#123;key=value,key=value&#125;"</span></span><br><span class="line">    其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=<span class="string">"getTeacher"</span> resultType=<span class="string">"teacher"</span>&gt;</span><br><span class="line">    select * from teacher <span class="built_in">where</span> id = <span class="comment">#&#123;id&#125; and name = #&#123;name&#125;</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testGetStudents</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; students = mapper.getStudents();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Student student : students)&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"学生名:"</span>+ student.getName()</span><br><span class="line">                        +<span class="string">"\t老师:"</span>+student.getTeacher().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="qiantao">按结果嵌套处理</h3>
除了上面这种方式，还有其他思路吗？

<p>我们还可以按照结果进行嵌套处理；<br>1.接口方法编写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public List&lt;Student&gt; getStudents2();</span><br></pre></td></tr></table></figure>

<p>2.编写对应的mapper文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">按查询结果嵌套处理</span><br><span class="line">思路：</span><br><span class="line">    1. 直接查询出结果，进行结果集的映射</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=<span class="string">"getStudents2"</span> resultMap=<span class="string">"StudentTeacher2"</span> &gt;</span><br><span class="line">    select s.id sid, s.name sname , t.name tname</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    <span class="built_in">where</span> s.tid = t.id</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=<span class="string">"StudentTeacher2"</span> <span class="built_in">type</span>=<span class="string">"Student"</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">"id"</span> column=<span class="string">"sid"</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">"name"</span> column=<span class="string">"sname"</span>/&gt;</span><br><span class="line">    &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span><br><span class="line">    &lt;association property=<span class="string">"teacher"</span> javaType=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">        &lt;result property=<span class="string">"name"</span> column=<span class="string">"tname"</span>/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>3.去mybatis-config文件中注入【此处应该处理过了】<br>4.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testGetStudents2</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; students = mapper.getStudents2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Student student : students)&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"学生名:"</span>+ student.getName()</span><br><span class="line">                        +<span class="string">"\t老师:"</span>+student.getTeacher().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xiaojie">小结</h3>
按照查询进行嵌套处理就像SQL中的子查询
按照结果进行嵌套处理就像SQL中的联表查询

<h2 id="yiduiduo">一对多的处理</h2>
一对多的理解：

<p>一个老师拥有多个学生<br>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！</p>
<h3 id="shitilei">实体类编写</h3>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Data </span><br><span class="line">public class Teacher &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    //一个老师多个学生</span><br><span class="line">    private List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>….. 和之前一样，搭建测试的环境！</p>
<h3 id="anjieguo2">按结果嵌套处理</h3>
1.TeacherMapper接口编写方法

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取指定老师，及老师下的所有学生</span><br><span class="line">public Teacher getTeacher(int id);</span><br></pre></td></tr></table></figure>

<p>2.编写接口对应的Mapper配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.kuang.mapper.TeacherMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    思路:</span><br><span class="line">        1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span><br><span class="line">        2. 对查询出来的操作做结果集映射</span><br><span class="line">            1. 集合的话，使用collection！</span><br><span class="line">                JavaType和ofType都是用来指定对象类型的</span><br><span class="line">                JavaType是用来指定pojo中属性的类型</span><br><span class="line">                ofType指定的是映射到list集合属性中pojo的类型。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=<span class="string">"getTeacher"</span> resultMap=<span class="string">"TeacherStudent"</span>&gt;</span><br><span class="line">        select s.id sid, s.name sname , t.name tname, t.id tid</span><br><span class="line">        from student s,teacher t</span><br><span class="line">        <span class="built_in">where</span> s.tid = t.id and t.id=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">"TeacherStudent"</span> <span class="built_in">type</span>=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">        &lt;result  property=<span class="string">"name"</span> column=<span class="string">"tname"</span>/&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"students"</span> ofType=<span class="string">"Student"</span>&gt;</span><br><span class="line">            &lt;result property=<span class="string">"id"</span> column=<span class="string">"sid"</span> /&gt;</span><br><span class="line">            &lt;result property=<span class="string">"name"</span> column=<span class="string">"sname"</span> /&gt;</span><br><span class="line">            &lt;result property=<span class="string">"tid"</span> column=<span class="string">"tid"</span> /&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>3.将Mapper文件注册到MyBatis-config文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">"mapper/TeacherMapper.xml"</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testGetTeacher</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    TeacherMapper mapper = session.getMapper(TeacherMapper.class);</span><br><span class="line">    Teacher teacher = mapper.getTeacher(1);</span><br><span class="line">    System.out.println(teacher.getName());</span><br><span class="line">    System.out.println(teacher.getStudents());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anchaxun2">按查询嵌套处理</h3>
1.TeacherMapper接口编写方法

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public Teacher getTeacher2(int id);</span><br></pre></td></tr></table></figure>

<p>2.编写接口对应的Mapper配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"getTeacher2"</span> resultMap=<span class="string">"TeacherStudent2"</span>&gt;</span><br><span class="line">  select * from teacher <span class="built_in">where</span> id = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">"TeacherStudent2"</span> <span class="built_in">type</span>=<span class="string">"Teacher"</span>&gt;</span><br><span class="line">    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span><br><span class="line">    &lt;collection property=<span class="string">"students"</span> javaType=<span class="string">"ArrayList"</span> ofType=<span class="string">"Student"</span> column=<span class="string">"id"</span> select=<span class="string">"getStudentByTeacherId"</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=<span class="string">"getStudentByTeacherId"</span> resultType=<span class="string">"Student"</span>&gt;</span><br><span class="line">    select * from student <span class="built_in">where</span> tid = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.将Mapper文件注册到MyBatis-config文件中<br>4.测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testGetTeacher2</span></span>()&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSession();</span><br><span class="line">    TeacherMapper mapper = session.getMapper(TeacherMapper.class);</span><br><span class="line">    Teacher teacher = mapper.getTeacher2(1);</span><br><span class="line">    System.out.println(teacher.getName());</span><br><span class="line">    System.out.println(teacher.getStudents());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xiaojie2">小结</h3>
1.关联-association
2.集合-collection
3.所以association是用于一对一和多对一，而collection是用于一对多的关系
4.JavaType和ofType都是用来指定对象类型的

<p>● JavaType是用来指定pojo中属性的类型<br>● ofType指定的是映射到list集合属性中pojo的类型。<br><b>注意说明：</b></p>
<p>1.保证SQL的可读性，尽量通俗易懂<br>2.根据实际要求，尽量编写性能更高的SQL语句<br>3.注意属性名和字段不一致的问题<br>4.注意一对多和多对一 中：字段和属性对应的问题<br>5.尽量使用Log4j，通过日志来查看自己的错误</p>
]]></content>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis简介及第一个程序</title>
    <url>/2020/03/15/Mybatis%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>环境说明：</p>
<p>jdk 8 +<br>MySQL 5.7.19<br>maven-3.6.0<br>IDEA<br>学习前需要掌握：</p>
<p>JDBC<br>MySQL<br>Java 基础<br>Maven<br>Junit</p>
<h3>什么是MyBatis</h3>
MyBatis 是一款优秀的持久层框架
MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程
MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。
MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。
2013年11月迁移到Github .
Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html
GitHub : https://github.com/mybatis/mybatis-3
<a id="more"></a>
<h3>持久化</h3>>
持久化是将程序数据在持久状态和瞬时状态间转换的机制。

<p>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。<br>JDBC就是一种持久化机制。文件IO也是一种持久化机制。<br>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。<br>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</p>
<p>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。<br>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</p>
<h3>持久层</h3>>
什么是持久层？

<p>完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】<br>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。<br>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现.<br>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】</p>
<h3>为什么需要Mybatis</h3>
Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .
传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等... , 通过框架可以减少重复代码,提高开发效率 .
MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) -->对象关系映射
所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别
MyBatis的优点

<p>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。<br>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。<br>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。<br>提供xml标签，支持编写动态sql。<br>…….<br>最重要的一点，使用的人多！公司需要！</p>
<h2>MyBatis第一个程序</h2>
思路流程：搭建环境-->导入Mybatis--->编写代码--->测试
1.搭建实验数据库

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(20) NOT NULL,</span><br><span class="line">  `name` varchar(30) DEFAULT NULL,</span><br><span class="line">  `<span class="built_in">pwd</span>` varchar(30) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert  into `user`(`id`,`name`,`<span class="built_in">pwd</span>`) values (1,<span class="string">'狂神'</span>,<span class="string">'123456'</span>),(2,<span class="string">'张三'</span>,<span class="string">'abcdef'</span>),(3,<span class="string">'李四'</span>,<span class="string">'987654'</span>);</span><br></pre></td></tr></table></figure>

<p>2.导入MyBatis相关jar 包<br>mysql注意自己的版本，5版本和8版本和自己的版本不一致会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.编写MyBatis核心配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=<span class="string">"development"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"development"</span>&gt;</span><br><span class="line">            &lt;transactionManager <span class="built_in">type</span>=<span class="string">"JDBC"</span>/&gt;</span><br><span class="line">            &lt;dataSource <span class="built_in">type</span>=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"com/kuang/dao/userMapper.xml"</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>连接数据库<br><img src="/images/innerimage/MybatisImage/315001.png" alt="cg"><br><img src="/images/innerimage/MybatisImage/315002.png" alt="cg"><br>4.编写MyBatis工具类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class MybatisUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取SqlSession连接</span><br><span class="line">    public static SqlSession <span class="function"><span class="title">getSession</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.创建实体类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    private int id;  //id</span><br><span class="line">    private String name;   //姓名</span><br><span class="line">    private String <span class="built_in">pwd</span>;   //密码</span><br><span class="line">    </span><br><span class="line">    //构造,有参,无参</span><br><span class="line">    //<span class="built_in">set</span>/get</span><br><span class="line">    //toString()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写Mapper接口类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import com.kuang.pojo.User;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.编写Mapper.xml配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.kuang.dao.UserMapper"</span>&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser"</span> resultType=<span class="string">"com.kuang.pojo.User"</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>8.编写测试类<br>junit包测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">selectUser</span></span>() &#123;</span><br><span class="line">        SqlSession session = MybatisUtils.getSession();</span><br><span class="line">        //方法一:</span><br><span class="line">        //List&lt;User&gt; users = session.selectList(<span class="string">"com.kuang.mapper.UserMapper.selectUser"</span>);</span><br><span class="line">        //方法二:</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user: users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.运行测试</p>
<h3>问题说明</h3>>
可能出现问题说明：Maven静态资源过滤问题

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;<span class="literal">false</span>&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;<span class="literal">false</span>&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>HTTP500的错误001</title>
    <url>/2020/03/14/HTTP500/</url>
    <content><![CDATA[<p><img src="/images/innerimage/HttpMessageNotWritableException.png" alt="img"><br><img src="/images/innerimage/HttpMessageNotWritableException2.png" alt="img"></p>
<h2>源代码</h2>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>-spring-mvc -http-500</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫肝了12小时</title>
    <url>/2020/03/10/%E7%88%AC%E8%99%AB%E8%82%9D%E4%BA%8612%E5%B0%8F%E6%97%B6/</url>
    <content><![CDATA[<p>今天属实值得纪念为了一个爬虫从8:30肝到20:30<br>原网址：<a href="https://blog.csdn.net/qq_38898129/article/details/89576581" target="_blank" rel="noopener">https://blog.csdn.net/qq_38898129/article/details/89576581</a><br>源代码：<br>import  requests<br>import time<br>from lxml import etree<br>url = ‘<a href="http://desk.zol.com.cn/dongman/1920x1080/&#39;" target="_blank" rel="noopener">http://desk.zol.com.cn/dongman/1920x1080/&#39;</a></p>
<a id="more"></a>
<p>headers = {“Referer”:”Referer: <a href="http://desk.zol.com.cn/dongman/1920x1080/&quot;" target="_blank" rel="noopener">http://desk.zol.com.cn/dongman/1920x1080/&quot;</a>,<br>    “User-Agent”:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36”,}</p>
<p>resq = requests.get(url,headers = headers)</p>
<p>print(resq)</p>
<p>html = etree.HTML(resq.text)<br>srcs = html.xpath(“.//img/@src”)</p>
<p>def download_img(url):<br>    imgname = url.split(‘/‘)[-1]<br>    img = requests.get(url, headers = headers)<br>    with open(‘imgs1/‘+imgname,’wb’) as file:<br>        file.write(img.content)<br>        print(url, imgname)</p>
<p>def next_page(url):<br>    res = requests.get(url, headers = headers)<br>    html = etree.HTML(res.text)<br>    srcs = html.xpath(“.//img/@src”)<br>    for i in srcs:<br>        download_img(i)<br>    next_page_link = html.xpath(‘.//a[@id=”pageNext”]/@href’)<br>    return next_page_link</p>
<p>def main():<br>    current_page = 1<br>    next_page_base = ‘<a href="http://desk.zol.com.cn/dongman/1920x1080/&#39;" target="_blank" rel="noopener">http://desk.zol.com.cn/dongman/1920x1080/&#39;</a><br>    next_page_link = html.xpath(‘.//a[@id=”pageNext”]/@href’)<br>    while next_page_link:<br>        current_page=current_page + 1<br>        next_page_link = next_page(next_page_base+str(current_page)+’.html’)<br>        if current_page &gt; 10:<br>            break</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>本来是比较高质量且通俗易懂的代码了，奈何老师给你整个比你岁数都大的网址，我吐了<br>网址：<a href="http://video.sina.com.cn/movie/category/movie/type/1.html" target="_blank" rel="noopener">http://video.sina.com.cn/movie/category/movie/type/1.html</a><br>肝后代码：<br>import  requests<br>import time<br>from lxml import etree<br>url = ‘<a href="http://video.sina.com.cn/movie/category/movie/type/1.html&#39;" target="_blank" rel="noopener">http://video.sina.com.cn/movie/category/movie/type/1.html&#39;</a></p>
<p>url = ‘<a href="http://video.sina.com.cn/movie/category/movie/type/1.html&#39;" target="_blank" rel="noopener">http://video.sina.com.cn/movie/category/movie/type/1.html&#39;</a><br>headers = {“Referer”: “<a href="http://video.sina.com.cn/movie/category/movie/type/1.html&quot;" target="_blank" rel="noopener">http://video.sina.com.cn/movie/category/movie/type/1.html&quot;</a>,<br>           “User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/“}<br>resq = requests.get(url,headers = headers)</p>
<p>print(resq)</p>
<p>html = etree.HTML(resq.text)<br>srcs = html.xpath(“//img[@onerror]/@src”)</p>
<p>print(srcs)<br>def download_img(url):<br>    imgname = url.split(‘/‘)[-1]<br>    img = requests.get(url, headers = headers)<br>    with open(‘imgs/‘+imgname,’wb’) as file:<br>        file.write(img.content)<br>        print(url, imgname)</p>
<p>def next_page(url):<br>    res = requests.get(url, headers = headers)<br>    html = etree.HTML(res.text)<br>    srcs = html.xpath(“//img[@onerror]/@src”)<br>    for i in srcs:<br>        download_img(i)<br>    next_page_link = html.xpath(“//img[@onerror]/@src”)<br>    return next_page_link</p>
<p>def main():<br>    current_page = 1<br>    next_page_base = ‘<a href="http://video.sina.com.cn/movie/category/movie/type/&#39;" target="_blank" rel="noopener">http://video.sina.com.cn/movie/category/movie/type/&#39;</a><br>    next_page_link = next_page_base+str(current_page)+’.html’<br>    print(next_page_link)<br>    while next_page_link:<br>        current_page=current_page + 1<br>        next_page_link = next_page(next_page_base+str(current_page)+’.html’)<br>        print(next_page_link)<br>        print(‘xxxxxxxxxxxxxxxxxxxxxxxxxxxxx’)</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>完结，撒花<br><img src="/images/%E7%88%AC%E8%99%AB.png" alt="cg"></p>
]]></content>
      <tags>
        <tag>-肝 -Python</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐鉴赏环节</title>
    <url>/2020/03/06/%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F%E7%8E%AF%E8%8A%82/</url>
    <content><![CDATA[<p>卫庄赤练撒糖</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=525258051&auto=0&height=66"></iframe>]]></content>
  </entry>
  <entry>
    <title>爱情公寓5机密档案</title>
    <url>/2020/03/06/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%935%E6%9C%BA%E5%AF%86%E6%A1%A3%E6%A1%88/</url>
    <content><![CDATA[<p>彩蛋在此</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>
<a id="more"></a>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=2" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=3" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=4" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=5" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=6" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=7" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=8" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=9" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=10" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=11" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=12" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=13" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=14" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=15" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=16" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=17" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=18" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=89027928&cid=152069234&page=19" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
  </entry>
  <entry>
    <title>成果也是诸葛大力</title>
    <url>/2020/03/04/%E6%88%90%E6%9E%9C%E4%B9%9F%E6%98%AF%E8%AF%B8%E8%91%9B%E5%A4%A7%E5%8A%9B/</url>
    <content><![CDATA[<p><img src="/images/guoguo.jpg" alt="cg"></p>
<p><img src="/images/guoguo2.jpg" alt="cg"></p>
<p><img src="/images/guoguo4.jpg" alt="cg"></p>
]]></content>
      <categories>
        <category>-银河 -太阳系 -地球</category>
      </categories>
      <tags>
        <tag>-女神 -演员 -爱情公寓5</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
